/-
Copyright (c) 2024 Xavier Roblot. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Xavier Roblot
-/
import Mathlib.Analysis.Asymptotics.SpecificAsymptotics
import Mathlib.Analysis.InnerProductSpace.Calculus
import Mathlib.Analysis.SpecialFunctions.ImproperIntegrals
import Mathlib.NumberTheory.AbelSummation
import Mathlib.NumberTheory.LSeries.Dirichlet

/-!
  # Docs
-/

open Finset Filter MeasureTheory Topology Complex Asymptotics

-- Clear the Asymptotics

section lemmas

theorem aux‚ÇÅ {f : ‚Ñï ‚Üí ‚ÑÇ} {s : ‚ÑÇ} {n : ‚Ñï} :
    LSeries.term f s n = (n : ‚ÑÇ) ^ (- s) * (fun n ‚Ü¶ if n = 0 then 0 else f n) n := by
  cases n with
  | zero => simp only [LSeries.term_zero, Nat.cast_eq_zero, reduceIte, mul_zero]
  | succ n =>
      dsimp only
      rw [LSeries.term_of_ne_zero (by omega), if_neg (by omega), div_eq_mul_inv,
        Complex.cpow_neg, mul_comm]

theorem aux‚ÇÇ {r : ‚Ñù} (hr : r < -1) :
    IntegrableAtFilter (fun t : ‚Ñù  ‚Ü¶ t ^ r) atTop :=
  ‚ü®Set.Ioi 1, Ioi_mem_atTop 1, (integrableOn_Ioi_rpow_iff zero_lt_one).mpr hr‚ü©

theorem aux‚ÇÉ {t : ‚Ñù} {c : ‚ÑÇ} (ht : t ‚â† 0) (hc : c ‚â† 0) :
    DifferentiableAt ‚Ñù (fun x : ‚Ñù ‚Ü¶ ‚Äñ(fun t ‚Ü¶ (t : ‚ÑÇ) ^ c) x‚Äñ) t :=
  (differentiableAt_id.ofReal_cpow_const ht hc).norm ‚Ñù
    ((cpow_ne_zero_iff hc).mpr <| ofReal_ne_zero.mpr ht)

theorem aux‚ÇÑ‚ÇÄ {t : ‚Ñù} {c : ‚ÑÇ} (ht : 0 < t):
    ‚Äñ(t : ‚ÑÇ) ^ c‚Äñ = t ^ c.re := by
  rw [Complex.norm_eq_abs, Complex.abs_cpow_eq_rpow_re_of_pos ht]

theorem aux‚ÇÑ‚ÇÅ {t : ‚Ñù} {c : ‚ÑÇ} (ht : 0 < t) :
    (deriv fun t : ‚Ñù ‚Ü¶ ‚Äñ(t : ‚ÑÇ) ^ c‚Äñ) t = c.re * t ^ (c.re - 1) := by
  rw [‚Üê Real.deriv_rpow_const (Or.inl ht.ne')]
  refine Filter.EventuallyEq.deriv_eq ?_
  filter_upwards [eventually_gt_nhds ht] with x hx
  exact aux‚ÇÑ‚ÇÄ hx

theorem aux‚ÇÑ‚ÇÅ‚ÇÅ {c : ‚ÑÇ} :
    (deriv fun t : ‚Ñù ‚Ü¶ ‚Äñ(t : ‚ÑÇ) ^ c‚Äñ) =·∂†[atTop] fun t ‚Ü¶ c.re * t ^ (c.re - 1) := by
  filter_upwards [eventually_gt_atTop 0] with t ht using aux‚ÇÑ‚ÇÅ ht

theorem aux‚ÇÑ‚ÇÇ {t : ‚Ñù} {c : ‚ÑÇ} (ht : t ‚â† 0) (hc : c ‚â† 0) :
    (deriv fun (t : ‚Ñù) ‚Ü¶ (t : ‚ÑÇ) ^ c) t = c * (t : ‚ÑÇ) ^ (c - 1) :=
  deriv_ofReal_cpow_const ht hc

theorem aux‚ÇÑ {c : ‚ÑÇ} (hc : 0 < c.re) :
    IntegrableOn (deriv fun t : ‚Ñù ‚Ü¶ ‚Äñ(t : ‚ÑÇ) ^ (- c)‚Äñ) (Set.Ici 1) := by
  refine IntegrableOn.congr_fun (Integrable.const_mul ?_ _)
    (fun t ht ‚Ü¶ (aux‚ÇÑ‚ÇÅ (zero_lt_one.trans_le ht)).symm) measurableSet_Ici
  exact integrableOn_Ici_iff_integrableOn_Ioi.mpr <|
    (integrableOn_Ioi_rpow_iff zero_lt_one).mpr
      (by rwa [sub_lt_iff_lt_add, neg_add_cancel, neg_re, neg_lt_zero])

theorem aux‚ÇÖ {R : Type*} [AddCommMonoid R] {f : ‚Ñï ‚Üí R} {n : ‚Ñï} :
    ‚àë k ‚àà Icc 0 n, (fun n ‚Ü¶ if n = 0 then 0 else f n) k =
      ‚àë k ‚àà Icc 1 n, f k := by
  rw [‚Üê Nat.Icc_insert_succ_left n.zero_le, sum_insert (mem_Icc.not.mpr (by omega)),
    zero_add, if_pos rfl, zero_add]
  exact Finset.sum_congr rfl
    (fun _ h ‚Ü¶ by rw [if_neg (zero_lt_one.trans_le (mem_Icc.mp h).1).ne'])

theorem aux‚ÇÜ {f : ‚Ñï ‚Üí ‚ÑÇ} {n : ‚Ñï} :
    ‚àë k ‚àà Icc 0 n, ‚Äñ(fun n ‚Ü¶ if n = 0 then 0 else f n) k‚Äñ =
      ‚àë k ‚àà Icc 1 n, ‚Äñf k‚Äñ := by
  simp_rw [apply_ite, norm_zero]
  exact aux‚ÇÖ

theorem aux‚Çá‚ÇÄ (c : ‚ÑÇ) :
    (fun t : ‚Ñù ‚Ü¶ ‚Äñ(t : ‚ÑÇ) ^ c‚Äñ) =O[atTop] fun t ‚Ü¶ t ^ c.re := by
  refine EventuallyEq.isBigO ?_
  filter_upwards [eventually_gt_atTop 0] with t ht
  rw [aux‚ÇÑ‚ÇÄ ht]

theorem aux‚Çá (c : ‚ÑÇ) :
    (fun n : ‚Ñï ‚Ü¶ ‚Äñ(n : ‚ÑÇ) ^ c‚Äñ) =O[atTop] fun n ‚Ü¶ (n : ‚Ñù) ^ c.re :=
  (aux‚Çá‚ÇÄ c).natCast_atTop

theorem aux‚Çà‚ÇÄ {r : ‚Ñù} (hr : 0 < r) :
    Tendsto (fun n : ‚Ñï ‚Ü¶ (n : ‚Ñù) ^ (-r)) atTop (ùìù 0) := by
  exact (tendsto_rpow_neg_atTop hr).comp tendsto_natCast_atTop_atTop

theorem aux‚Çà {r a : ‚Ñù} (hr : 0 < r) (ha : 0 < a) :
    ‚àÄ·∂† (x : ‚Ñï) in atTop, ‚Äñ(x : ‚Ñù) ^ (- r)‚Äñ < a :=
  (NormedAddCommGroup.tendsto_nhds_zero.mp (aux‚Çà‚ÇÄ hr)) _ ha

theorem aux‚Çâ {ùïú : Type*} [RCLike ùïú] {m : ‚Ñï} {f : ‚Ñï ‚Üí ùïú} {r : ‚Ñù} (hr : 0 ‚â§ r)
    (hbO : (fun n ‚Ü¶ ‚àë k ‚àà Icc m n, f k) =O[atTop] fun n ‚Ü¶ (n : ‚Ñù) ^ r) :
    (fun t : ‚Ñù ‚Ü¶ ‚àë k ‚àà Icc m ‚åät‚åã‚Çä, f k) =O[atTop] fun t : ‚Ñù ‚Ü¶ t ^ r := by
  refine (hbO.comp_tendsto tendsto_nat_floor_atTop).trans <|
    isEquivalent_nat_floor.isBigO.rpow hr ?_
  filter_upwards [eventually_ge_atTop 0] with _ ht using ht

theorem aux‚ÇÅ‚ÇÄ {t : ‚Ñù} {c : ‚ÑÇ} (ht : t ‚â† 0) (hc : c ‚â† 0) :
    DifferentiableAt ‚Ñù (fun x : ‚Ñù ‚Ü¶ (x : ‚ÑÇ) ^ c) t :=
  differentiableAt_id.ofReal_cpow_const ht hc

theorem aux‚ÇÅ‚ÇÅ {c : ‚ÑÇ} (hc : 0 < c.re) :
    IntegrableOn (deriv fun x : ‚Ñù ‚Ü¶ (x : ‚ÑÇ) ^ (- c)) (Set.Ici 1) := by
  refine IntegrableOn.congr_fun ?_ (fun t ht ‚Ü¶ by
    rw [deriv_ofReal_cpow_const (zero_lt_one.trans_le ht).ne'
      (neg_ne_zero.mpr <| ne_zero_of_re_pos hc)]) measurableSet_Ici
  refine integrableOn_Ici_iff_integrableOn_Ioi.mpr <|
    Integrable.const_mul ((integrableOn_Ioi_cpow_iff zero_lt_one).mpr ?_) _
  rwa [sub_re, one_re, sub_lt_iff_lt_add, neg_add_cancel, neg_re, neg_lt_zero]

theorem aux‚ÇÅ‚ÇÇ {c : ‚ÑÇ} (hc : c ‚â† 0) :
    (fun t ‚Ü¶ deriv (fun x : ‚Ñù ‚Ü¶ (x : ‚ÑÇ) ^ c) t) =O[atTop] fun t ‚Ü¶ t ^ (c.re - 1) := by
  refine IsBigO.congr_left' (f‚ÇÅ := fun t : ‚Ñù ‚Ü¶ c * (t : ‚ÑÇ) ^ (c - 1)) ?_ ?_
  ¬∑ refine Asymptotics.IsBigO.const_mul_left ?_ _
    rw [‚Üê Asymptotics.isBigO_norm_left]
    refine EventuallyEq.isBigO ?_
    filter_upwards [eventually_gt_atTop 0] with t ht
    rw [aux‚ÇÑ‚ÇÄ ht, sub_re, one_re]
  ¬∑ filter_upwards [eventually_ne_atTop 0] with t ht
    rw [aux‚ÇÑ‚ÇÇ ht hc]

theorem aux‚ÇÅ‚ÇÉ {ùïú : Type*} [RCLike ùïú] {f g : ‚Ñù ‚Üí ùïú} (a b c : ‚Ñù)
    (hf : f =O[atTop] fun t ‚Ü¶ (t : ‚Ñù) ^ a)
    (hg : g =O[atTop] fun t ‚Ü¶ (t : ‚Ñù) ^ b) (h : a + b ‚â§ c) :
    (f * g) =O[atTop] fun t ‚Ü¶ (t : ‚Ñù) ^ c := by
  refine (hf.mul hg).trans (Eventually.isBigO ?_)
  filter_upwards [eventually_ge_atTop 1] with t ht
  rw [‚Üê Real.rpow_add (zero_lt_one.trans_le ht), Real.norm_of_nonneg (Real.rpow_nonneg
    (zero_le_one.trans ht) (a + b))]
  exact Real.rpow_le_rpow_of_exponent_le ht h

theorem aux‚ÇÅ‚ÇÑ {ùïú : Type*} [RCLike ùïú] {f g : ‚Ñï ‚Üí ùïú} (a b c : ‚Ñù)
    (hf : f =O[atTop] fun n ‚Ü¶ (n : ‚Ñù) ^ a)
    (hg : g =O[atTop] fun n ‚Ü¶ (n : ‚Ñù) ^ b) (h : a + b ‚â§ c) :
    (f * g) =O[atTop] fun n ‚Ü¶ (n : ‚Ñù) ^ c := by
  refine (hf.mul hg).trans (Eventually.isBigO ?_)
  filter_upwards [eventually_ge_atTop 1] with t ht
  replace ht : 1 ‚â§ (t : ‚Ñù) := Nat.one_le_cast.mpr ht
  rw [‚Üê Real.rpow_add (zero_lt_one.trans_le ht), Real.norm_of_nonneg (Real.rpow_nonneg
    (zero_le_one.trans ht) (a + b))]
  exact Real.rpow_le_rpow_of_exponent_le ht h

end lemmas

section summable

variable {f : ‚Ñï ‚Üí ‚ÑÇ} {r : ‚Ñù} {s : ‚ÑÇ}

theorem LSeriesSummable_of_sum_norm_bigO
    (hO : (fun n ‚Ü¶ ‚àë k ‚àà Icc 1 n, ‚Äñf k‚Äñ) =O[atTop] fun n ‚Ü¶ (n : ‚Ñù) ^ r)
    (hr : 0 ‚â§ r) (hs : r < s.re) :
    LSeriesSummable f s := by
  change Summable (fun n ‚Ü¶ LSeries.term f s n)
  simp_rw [aux‚ÇÅ]
  simp_rw [‚Üê aux‚ÇÜ] at hO
  refine summable_mul_of_bigO_atTop‚ÇÄ (fun n ‚Ü¶ if n = 0 then 0 else f n)
    (f := fun t ‚Ü¶ (t : ‚ÑÇ) ^ (-s)) (g := fun t ‚Ü¶ t ^ ((- s - 1).re + r)) ?_ ?_ ?_ ?_ ?_ (aux‚ÇÇ ?_)
  ¬∑ simp
  ¬∑ intro t ht
    refine aux‚ÇÉ ?_ ?_
    ¬∑ -- t ‚â† 0
      exact (zero_lt_one.trans_le ht).ne'
    ¬∑ -- -s ‚â† 0
      exact neg_ne_zero.mpr <| ne_zero_of_re_pos (hr.trans_lt hs)
  ¬∑ refine aux‚ÇÑ ?_
    exact hr.trans_lt hs
  ¬∑ have : (-s).re + r ‚â§ 0 := by
      rw [neg_re, neg_add_nonpos_iff]
      exact hs.le
    convert aux‚ÇÅ‚ÇÑ ((- s).re) r 0 ?_ ?_ this
    ¬∑ rw [Real.rpow_zero]
    ¬∑ exact aux‚Çá (- s)
    ¬∑ exact hO
  ¬∑ refine aux‚ÇÅ‚ÇÉ ((- s).re - 1) r _ ?_ ?_ ?_
    ¬∑ exact (EventuallyEq.isBigO aux‚ÇÑ‚ÇÅ‚ÇÅ).of_const_mul_right
    ¬∑ exact aux‚Çâ hr hO
    ¬∑ rw [sub_re, one_re]
  ¬∑ -- (-s - 1).re + r < -1
    rwa [sub_re, one_re, neg_re, neg_sub_left, neg_add_lt_iff_lt_add, add_neg_cancel_comm]

end summable

section integral_repr

theorem integral_repr (f : ‚Ñï ‚Üí ‚ÑÇ)
    {r : ‚Ñù}
    (hr : 0 ‚â§ r)
    {s : ‚ÑÇ}
    (hs : r < s.re)
    (hS : LSeriesSummable f s)
    (hO : (fun n ‚Ü¶ ‚àë k ‚àà Icc 1 n, f k) =O[atTop] fun n ‚Ü¶ (n : ‚Ñù) ^ r) :
    LSeries f s = s * ‚à´ t in Set.Ioi (1 : ‚Ñù), (‚àë k ‚àà Icc 1 ‚åät‚åã‚Çä, f k) * t ^ (- s - 1) := by
  rw [‚Üê integral_mul_left]
  simp_rw [‚Üê aux‚ÇÖ] at hO
  refine tendsto_nhds_unique ((tendsto_add_atTop_iff_nat 1).mpr hS.hasSum.tendsto_sum_nat) ?_
  simp_rw [Nat.range_eq_Icc_zero_sub_one _ (Nat.add_one_ne_zero _), add_tsub_cancel_right,
    aux‚ÇÅ, ‚Üê aux‚ÇÖ, mul_comm]
  have : (-s - 1).re + r < -1 := by
    rwa [sub_re, one_re, neg_re, neg_sub_left, neg_add_lt_iff_lt_add, add_neg_cancel_comm]
  convert tendsto_sum_mul_atTop_eq_sub_integral‚ÇÄ (f := fun x ‚Ü¶ (x : ‚ÑÇ) ^ (-s)) (l := 0)
    ?_ ?_ ?_ ?_ ?_ ?_ (aux‚ÇÇ this)
  ¬∑ rw [zero_sub, ‚Üê integral_neg]
    refine setIntegral_congr_fun measurableSet_Ioi fun t ht ‚Ü¶ ?_
    rw [deriv_ofReal_cpow_const]
    ¬∑ ring
    ¬∑ exact (zero_lt_one.trans ht).ne'
    ¬∑ exact neg_ne_zero.mpr <| ne_zero_of_re_pos (hr.trans_lt hs)
  ¬∑ simp
  ¬∑ intro t ht
    refine aux‚ÇÅ‚ÇÄ ?_ ?_
    ¬∑ exact (zero_lt_one.trans_le ht).ne'
    ¬∑ exact neg_ne_zero.mpr <| ne_zero_of_re_pos (hr.trans_lt hs)
  ¬∑ refine aux‚ÇÅ‚ÇÅ (hr.trans_lt hs)
  ¬∑ refine Asymptotics.IsBigO.trans_tendsto ?_ (aux‚Çà‚ÇÄ (r := s.re -r) ?_)
    ¬∑ refine aux‚ÇÅ‚ÇÑ (ùïú := ‚ÑÇ) (- s.re) _ _ ?_ hO ?_
      ¬∑ rw [‚Üê Asymptotics.isBigO_norm_left]
        exact aux‚Çá (- s)
      ¬∑ rw [neg_sub, neg_add_eq_sub]
    ¬∑ rwa [sub_pos]
  ¬∑ refine aux‚ÇÅ‚ÇÉ (- s.re - 1) r _ ?_ ?_ (by simp only [sub_re, neg_re, one_re, le_refl])
    ¬∑ exact isBigO_deriv_ofReal_cpow_const_atTop (-s)
    ¬∑ exact aux‚Çâ hr hO

end integral_repr

section Riemann

example (s : ‚ÑÇ) (hs : 1 < s.re) :
    riemannZeta s = s * ‚à´ t in Set.Ioi (1 : ‚Ñù), ‚åät‚åã‚Çä / (t : ‚ÑÇ) ^ (s + 1) := by
  rw [‚Üê LSeries_one_eq_riemannZeta hs]
  rw [integral_repr _ zero_le_one hs (LSeriesSummable_one_iff.mpr hs)]
  ¬∑ rw [mul_right_inj' (Complex.ne_zero_of_one_lt_re hs)]
    refine setIntegral_congr_fun measurableSet_Ioi fun t ht ‚Ü¶ ?_
    simp_rw [Pi.one_apply, sum_const, Nat.card_Icc, add_tsub_cancel_right, nsmul_eq_mul, mul_one,
      div_eq_mul_inv, ‚Üê Complex.cpow_neg, neg_add']
  ¬∑ simp_rw [Real.rpow_one]
    refine Eventually.isBigO ?_
    filter_upwards with n using by simp

end Riemann

noncomputable section Residue

variable (f : ‚Ñï ‚Üí ‚ÑÇ) {l : ‚ÑÇ}
  (hlim : Tendsto (fun n : ‚Ñï ‚Ü¶ (‚àë k ‚àà Icc 1 n, f k : ‚ÑÇ) / n) atTop (ùìù l))

include hlim in
theorem step1 {Œµ : ‚Ñù} (hŒµ : Œµ > 0) :
    ‚àÄ·∂† t : ‚Ñù in atTop, ‚Äñ(‚àë k ‚àà Icc 1 ‚åät‚åã‚Çä, f k) - l * t‚Äñ < Œµ * t := by
  have h_lim' : Tendsto (fun t : ‚Ñù ‚Ü¶ (‚àë k ‚àà Icc 1 ‚åät‚åã‚Çä, f k : ‚ÑÇ) / t) atTop (ùìù l) := by
    have := (hlim.comp tendsto_nat_floor_atTop).mul <|
      tendsto_ofReal_iff.mpr <| tendsto_nat_floor_div_atTop
    rw [ofReal_one, mul_one] at this
    refine this.congr' ?_
    filter_upwards [eventually_ge_atTop 1] with t ht
    rw [Function.comp_def, ofReal_div, ofReal_natCast, div_mul_div_cancel‚ÇÄ]
    rwa [Nat.cast_ne_zero, ne_eq, Nat.floor_eq_zero, not_lt]
  rw [Metric.tendsto_nhds] at h_lim'
  filter_upwards [eventually_gt_atTop 0, h_lim' Œµ hŒµ] with t ht‚ÇÅ ht‚ÇÇ
  rwa [dist_eq_norm, div_sub' _ _ _ (ne_zero_of_re_pos ht‚ÇÅ), norm_div, norm_real,
    Real.norm_of_nonneg ht‚ÇÅ.le, mul_comm, div_lt_iff‚ÇÄ ht‚ÇÅ] at ht‚ÇÇ

theorem key‚ÇÅ {s : ‚Ñù} (hs : 1 < s ) : (s - 1) * ‚à´ (t : ‚Ñù) in Set.Ioi 1, t ^ (- s) = 1 := by
  rw [integral_Ioi_rpow_of_lt (by rwa [neg_lt_neg_iff]) zero_lt_one, Real.one_rpow, neg_div,
    mul_neg, mul_one_div, neg_div', neg_sub', sub_neg_eq_add, div_self
    (neg_add_eq_zero.not.mpr hs.ne')]

theorem key‚ÇÇ {s : ‚ÑÇ} (hs : 1 < s.re) :
    (s - 1) * ‚à´ (t : ‚Ñù) in Set.Ioi 1, (t : ‚ÑÇ) ^ (- s : ‚ÑÇ) = 1 := by
  rw [integral_Ioi_cpow_of_lt (by rwa [neg_re, neg_lt_neg_iff]) zero_lt_one, ofReal_one, one_cpow,
    neg_div, mul_neg, mul_one_div, neg_div', neg_sub', sub_neg_eq_add, div_self]
  contrapose! hs
  rw [neg_add_eq_zero.mp hs, one_re]

theorem key‚ÇÇ' {s : ‚Ñù} (hs : 1 < s) :
    (s - 1) * ‚à´ (t : ‚Ñù) in Set.Ioi 1, t ^ (- s) = 1 := by
  rw [integral_Ioi_rpow_of_lt (by rwa [neg_lt_neg_iff]) zero_lt_one, Real.one_rpow, neg_div,
    ‚Üê one_div_neg_eq_neg_one_div, neg_add', neg_neg, mul_one_div, div_self]
  rw [sub_ne_zero]
  exact hs.ne'

include hlim in
theorem key‚ÇÉ : (fun n : ‚Ñï ‚Ü¶ ‚àë k ‚àà Icc 1 n, f k) =O[atTop] fun n ‚Ü¶ (n : ‚Ñù) ^ (1 : ‚Ñù) := by
  simp_rw [Real.rpow_one]
  refine Asymptotics.isBigO_norm_left.mp <| Asymptotics.isBigO_of_div_tendsto_nhds ?_ ‚Äñl‚Äñ ?_
  ¬∑ filter_upwards [eventually_ne_atTop 0] with _ h using
      fun h' ‚Ü¶ False.elim <| h (Nat.cast_eq_zero.mp h')
  ¬∑ simpa only [Function.comp_def, norm_div, norm_natCast] using (tendsto_norm.comp hlim)

theorem key‚ÇÑ {a b : ‚Ñù} {c : ‚ÑÇ} (ha : 0 < a) :
    IntegrableOn (fun t : ‚Ñù ‚Ü¶ (t : ‚ÑÇ) ^ c) (Set.Icc a b) := by
  refine ContinuousOn.integrableOn_compact isCompact_Icc ?_
  exact continuous_ofReal.continuousOn.cpow_const
    (fun x hx ‚Ü¶ ofReal_mem_slitPlane.mpr (ha.trans_le hx.1))

theorem key‚ÇÖ {a : ‚Ñù} {c : ‚ÑÇ} (ha : 0 < a) (hc : 1 < c.re):
    IntegrableOn (fun t : ‚Ñù ‚Ü¶ (t : ‚ÑÇ) ^ (- c)) (Set.Ioi a) :=
  integrableOn_Ioi_cpow_of_lt (by rwa [neg_re, neg_lt_neg_iff]) ha

theorem key‚ÇÜ {a b : ‚Ñù} {c : ‚ÑÇ} (ha : 0 < a) :
    IntegrableOn (fun t : ‚Ñù ‚Ü¶ (‚àë k ‚àà Icc 1 ‚åät‚åã‚Çä, f k) * (t : ‚ÑÇ) ^ c) (Set.Icc a b) := by
  simp_rw [mul_comm]
  exact integrableOn_mul_sum _ ha.le (key‚ÇÑ ha)

include hlim in
theorem key‚Çá {a : ‚Ñù} {c : ‚ÑÇ} (ha : 0 < a) (hc : 1 < c.re) :
    IntegrableOn (fun t : ‚Ñù ‚Ü¶ (‚àë k ‚àà Icc 1 ‚åät‚åã‚Çä, f k) * (t : ‚ÑÇ) ^ (- (c + 1))) (Set.Ici a) := by
  refine LocallyIntegrableOn.integrableOn_of_isBigO_atTop (g := fun t ‚Ü¶ t ^ (- c.re)) ?_ ?_ ?_
  ¬∑ simp_rw [mul_comm]
    refine locallyIntegrableOn_mul_sum _ ha.le <|
      integrableOn_Ici_iff_integrableOn_Ioi.mpr (key‚ÇÖ ha ?_)
    rw [add_re, one_re, lt_add_iff_pos_left]
    exact zero_lt_one.trans hc
  ¬∑ refine aux‚ÇÅ‚ÇÉ 1 (- (c + 1).re) _ ?_ ?_ ?_
    ¬∑ exact aux‚Çâ zero_le_one (key‚ÇÉ f hlim)
    ¬∑ rw [‚Üê Asymptotics.isBigO_norm_left]
      exact aux‚Çá‚ÇÄ _
    ¬∑ simp only [add_re, one_re, neg_add_rev, add_neg_cancel_left, le_refl]
  ¬∑ refine aux‚ÇÇ ?_
    rwa [neg_lt_neg_iff]

theorem key‚Çà {T : ‚Ñù} {c : ‚ÑÇ} (hc : 1 < c.re) :
    ‚Äñ‚à´ (t : ‚Ñù) in Set.Ioc 1 T, (‚àë k ‚àà Icc 1 ‚åät‚åã‚Çä, f k) * (t : ‚ÑÇ) ^ (- c - 1)‚Äñ ‚â§
      ‚à´ (t : ‚Ñù) in Set.Ioc 1 T, ‚Äñ(‚àë k ‚àà Icc 1 ‚åät‚åã‚Çä, f k) * (t : ‚ÑÇ) ^ (-2 : ‚ÑÇ)‚Äñ := by
  by_cases hT : 1 < T
  ¬∑ refine le_trans (norm_integral_le_integral_norm _) ?_
    refine setIntegral_mono_on ?_ ?_ measurableSet_Ioc fun t ht ‚Ü¶ ?_
    ¬∑ rw [‚Üê neg_add']
      exact (integrableOn_Icc_iff_integrableOn_Ioc.mp <| key‚ÇÜ _ zero_lt_one).norm
    ¬∑ exact (integrableOn_Icc_iff_integrableOn_Ioc.mp <| key‚ÇÜ _ zero_lt_one).norm
    ¬∑ have ht' : 0 < t := zero_lt_one.trans ht.1
      rw [norm_mul, norm_mul, aux‚ÇÑ‚ÇÄ ht', aux‚ÇÑ‚ÇÄ ht', sub_re, one_re, neg_re, neg_re, re_ofNat]
      refine mul_le_mul_of_nonneg_left ?_ (norm_nonneg _)
      exact Real.rpow_le_rpow_of_exponent_le ht.1.le (by linarith)
  ¬∑ rw [Set.Ioc_eq_empty hT, setIntegral_empty, setIntegral_empty, norm_zero]

theorem key‚Çâ {T : ‚Ñù} {c : ‚ÑÇ} (hc :1 < c.re):
    ‚Äñl * ‚à´ (t : ‚Ñù) in Set.Ioc 1 T, (t : ‚ÑÇ) ^ (- c)‚Äñ ‚â§
      ‚Äñl‚Äñ * ‚à´ (t : ‚Ñù) in Set.Ioc 1 T, ‚Äñ(t : ‚ÑÇ) ^ (- 1 : ‚ÑÇ)‚Äñ := by
  by_cases hT : 1 < T
  ¬∑ rw [norm_mul]
    refine mul_le_mul_of_nonneg_left ?_ (norm_nonneg _)
    refine le_trans (norm_integral_le_integral_norm _) ?_
    refine setIntegral_mono_on ?_ ?_ measurableSet_Ioc fun t ht ‚Ü¶ ?_
    ¬∑ exact (integrableOn_Icc_iff_integrableOn_Ioc.mp <| key‚ÇÑ zero_lt_one).norm
    ¬∑ exact (integrableOn_Icc_iff_integrableOn_Ioc.mp <| key‚ÇÑ zero_lt_one).norm
    ¬∑ have ht' : 0 < t := zero_lt_one.trans ht.1
      rw [aux‚ÇÑ‚ÇÄ ht', aux‚ÇÑ‚ÇÄ ht', neg_re, neg_re, one_re]
      exact Real.rpow_le_rpow_of_exponent_le ht.1.le (neg_le_neg_iff.mpr hc.le)
  ¬∑ rw [Set.Ioc_eq_empty hT, setIntegral_empty, setIntegral_empty, mul_zero, norm_zero, mul_zero]

theorem key‚ÇÅ‚ÇÄ (Œµ : ‚Ñù) {T : ‚Ñù} {c : ‚ÑÇ} (hT : 0 < T) (hc : 1 < c.re) :
    IntegrableOn (fun t : ‚Ñù ‚Ü¶ ‚ÄñŒµ * t‚Äñ * ‚Äñ(t : ‚ÑÇ) ^ (- c - 1)‚Äñ) (Set.Ioi T) := by
  simp_rw [‚Üê norm_real, ‚Üê norm_mul, ofReal_mul, mul_assoc]
  refine (((key‚ÇÖ hT hc).congr ((ae_restrict_iff' measurableSet_Ioi).mpr ?_)).const_mul _).norm
  filter_upwards with t ht
  rw [cpow_sub, cpow_one, mul_div_cancel‚ÇÄ]
  all_goals exact_mod_cast (hT.trans ht).ne'

theorem key‚ÇÅ‚ÇÅ {g : ‚Ñï ‚Üí ‚ÑÇ} {c : ‚ÑÇ} :
     Measurable (fun t : ‚Ñù ‚Ü¶ ‚Äñ(‚àë k in Icc 1 ‚åät‚åã‚Çä, g k) - c * t‚Äñ) :=
  (((by exact fun _ _ ‚Ü¶ trivial : Measurable fun n : ‚Ñï ‚Ü¶ ‚àë k ‚àà Icc 1 n, g k).comp'
    Nat.measurable_floor).sub (by fun_prop)).norm

variable (hfS : ‚àÄ s : ‚Ñù, s > 1 ‚Üí LSeriesSummable f s)

include hlim hfS in
theorem key_step {Œµ : ‚Ñù} (hŒµ : Œµ > 0) :
    ‚àÉ C ‚â• 0, ‚àÄ s : ‚Ñù, 1 < s ‚Üí ‚Äñ(s - 1) * LSeries f s - l * s‚Äñ ‚â§ (s - 1) * s * C + s * Œµ := by
  obtain ‚ü®T‚ÇÄ, hT‚ÇÄ‚ü© := (eventually_atTop).mp <| step1 f hlim hŒµ
  let T := max 1 T‚ÇÄ
  have hT : 0 < T := zero_lt_one.trans_le (le_max_left _ _)
  let C‚ÇÅ := ‚à´ t in Set.Ioc 1 T, ‚Äñ(‚àë k ‚àà Icc 1 ‚åät‚åã‚Çä, f k) * (t : ‚ÑÇ) ^ (- 2 : ‚ÑÇ)‚Äñ
  let C‚ÇÇ := ‚Äñl‚Äñ * ‚à´ t in Set.Ioc 1 T, ‚Äñ(t : ‚ÑÇ) ^ (- 1 : ‚ÑÇ)‚Äñ
  refine ‚ü®C‚ÇÅ + C‚ÇÇ, ?_, ?_‚ü©
  ¬∑ exact add_nonneg (integral_nonneg fun _ ‚Ü¶ norm_nonneg _) <|
      mul_nonneg (norm_nonneg _) (integral_nonneg fun _ ‚Ü¶ norm_nonneg _)
  ¬∑ intro s hs
    have hs' : 0 ‚â§ (s - 1) * s := mul_nonneg (sub_nonneg.mpr hs.le) (zero_le_one.trans hs.le)
    have hT' : ‚àÄ t ‚àà Set.Ioi T,
        ‚Äñ‚àë k ‚àà Icc 1 ‚åät‚åã‚Çä, f k - l * t‚Äñ * ‚Äñ(t : ‚ÑÇ) ^ (- (s : ‚ÑÇ) - 1)‚Äñ ‚â§ ‚ÄñŒµ * t‚Äñ *
          ‚Äñ(t : ‚ÑÇ) ^ (- (s : ‚ÑÇ) - 1)‚Äñ := fun t ht ‚Ü¶ by
      refine mul_le_mul_of_nonneg_right ?_ (norm_nonneg _)
      rw [Real.norm_of_nonneg (mul_nonneg hŒµ.le (hT.trans ht).le)]
      exact (hT‚ÇÄ _ (le_trans (le_max_right 1 T‚ÇÄ) ht.le)).le
    let C‚ÇÅs := ‚à´ t in Set.Ioc 1 T, (‚àë k ‚àà Icc 1 ‚åät‚åã‚Çä, f k) * (t : ‚ÑÇ) ^ (- s - 1 : ‚ÑÇ)
    let C‚ÇÇs := l * ‚à´ t in Set.Ioc 1 T, (t : ‚ÑÇ) ^ (- s : ‚ÑÇ)
    calc
      _ = ‚Äñ(s - 1) * s *
            ((‚à´ (t : ‚Ñù) in Set.Ioi 1, (‚àë k ‚àà Icc 1 ‚åät‚åã‚Çä, f k) * (t : ‚ÑÇ) ^ (- s - 1 : ‚ÑÇ))
              - l * ‚à´ (t : ‚Ñù) in Set.Ioi 1, (t : ‚ÑÇ) ^ (- s : ‚ÑÇ))‚Äñ := ?_
      _ = ‚Äñ(s - 1) * s *
            ((‚à´ (t : ‚Ñù) in Set.Ioc 1 T, (‚àë k ‚àà Icc 1 ‚åät‚åã‚Çä, f k) * (t : ‚ÑÇ) ^ (- s - 1 : ‚ÑÇ)) +
              (‚à´ (t : ‚Ñù) in Set.Ioi T, (‚àë k ‚àà Icc 1 ‚åät‚åã‚Çä, f k) * (t : ‚ÑÇ) ^ (- s - 1 : ‚ÑÇ))
                - l * ((‚à´ (t : ‚Ñù) in Set.Ioc 1 T, (t : ‚ÑÇ) ^ (- s : ‚ÑÇ))
                  + (‚à´ (t : ‚Ñù) in Set.Ioi T, (t : ‚ÑÇ) ^ (- s : ‚ÑÇ))))‚Äñ := ?_
      _ = ‚Äñ(s - 1) * s * C‚ÇÅs  - (s - 1) * s * C‚ÇÇs +
            (s - 1) * s *
              ((‚à´ (t : ‚Ñù) in Set.Ioi T, (‚àë k ‚àà Icc 1 ‚åät‚åã‚Çä, f k) * (t : ‚ÑÇ) ^ (- s - 1 : ‚ÑÇ)) -
                l * (‚à´ (t : ‚Ñù) in Set.Ioi T, (t : ‚ÑÇ) ^ (- s : ‚ÑÇ)))‚Äñ := by congr; ring
      _ ‚â§ (s - 1) * s * ‚ÄñC‚ÇÅs‚Äñ + (s - 1) * s * ‚ÄñC‚ÇÇs‚Äñ +
            (s - 1) * s *
              ‚Äñ(‚à´ (t : ‚Ñù) in Set.Ioi T, (‚àë k ‚àà Icc 1 ‚åät‚åã‚Çä, f k) * (t : ‚ÑÇ) ^ (- s - 1 : ‚ÑÇ)) -
                l * (‚à´ (t : ‚Ñù) in Set.Ioi T, (t : ‚ÑÇ) ^ (- s : ‚ÑÇ))‚Äñ := ?_
      _ ‚â§ (s - 1) * s * C‚ÇÅ + (s - 1) * s * C‚ÇÇ +
            (s - 1) * s *
              ‚Äñ‚à´ (t : ‚Ñù) in Set.Ioi T,
                (‚àë k ‚àà Icc 1 ‚åät‚åã‚Çä, f k) * (t : ‚ÑÇ) ^ (- s - 1 : ‚ÑÇ) - l * (t : ‚ÑÇ) ^ (- s : ‚ÑÇ)‚Äñ := ?_
      _ = (s - 1) * s * (C‚ÇÅ + C‚ÇÇ) +
            (s - 1) * s *
              ‚Äñ‚à´ (t : ‚Ñù) in Set.Ioi T,
                ((‚àë k ‚àà Icc 1 ‚åät‚åã‚Çä, f k) - l * t) * (t : ‚ÑÇ) ^ (- s - 1 : ‚ÑÇ)‚Äñ := ?_
      _ ‚â§ (s - 1) * s * (C‚ÇÅ + C‚ÇÇ) +
            (s - 1) * s *
              ‚à´ (t : ‚Ñù) in Set.Ioi T,
                ‚Äñ((‚àë k ‚àà Icc 1 ‚åät‚åã‚Çä, f k) - l * t)‚Äñ * ‚Äñ(t : ‚ÑÇ) ^ (- s - 1 : ‚ÑÇ)‚Äñ := ?_
      _ ‚â§ (s - 1) * s * (C‚ÇÅ + C‚ÇÇ) +
            (s - 1) * s * ‚à´ (t : ‚Ñù) in Set.Ioi T, ‚ÄñŒµ * t‚Äñ * ‚Äñ(t : ‚ÑÇ) ^ (- s - 1 : ‚ÑÇ)‚Äñ := ?_
      _ ‚â§ (s - 1) * s * (C‚ÇÅ + C‚ÇÇ) +
            (s - 1) * s * ‚à´ (t : ‚Ñù) in Set.Ioi 1, ‚ÄñŒµ * t‚Äñ * ‚Äñ(t : ‚ÑÇ) ^ (- s - 1 : ‚ÑÇ)‚Äñ := ?_
      _ = (s - 1) * s * (C‚ÇÅ + C‚ÇÇ) +
            (s - 1) * s * ‚à´ (t : ‚Ñù) in Set.Ioi 1, Œµ * ‚Äñ(t : ‚ÑÇ) ^ (- s : ‚ÑÇ)‚Äñ := ?_
      _ = (s - 1) * s * (C‚ÇÅ + C‚ÇÇ) +
            s * Œµ * ((s - 1) * ‚à´ (t : ‚Ñù) in Set.Ioi 1, t ^ (- s)) := ?_
      _ = (s - 1) * s * (C‚ÇÅ + C‚ÇÇ) + s * Œµ := by rw [key‚ÇÇ' hs, mul_one]
    ¬∑ rw [integral_repr _ zero_le_one (by rwa [ofReal_re]) (hfS _ hs), mul_sub, ‚Üê mul_assoc _ l,
        mul_rotate _ _ l, mul_assoc, mul_assoc, key‚ÇÇ (by rwa [ofReal_re]), mul_one, mul_comm l]
      exact key‚ÇÉ f hlim
    ¬∑ rw [‚Üê Set.Ioc_union_Ioi_eq_Ioi (le_max_left 1 T‚ÇÄ)]
      rw [setIntegral_union (Set.Ioc_disjoint_Ioi le_rfl) measurableSet_Ioi, setIntegral_union
        (Set.Ioc_disjoint_Ioi le_rfl)
        measurableSet_Ioi]
      ¬∑ exact integrableOn_Icc_iff_integrableOn_Ioc.mp <| key‚ÇÑ zero_lt_one
      ¬∑ exact key‚ÇÖ hT (by rwa [ofReal_re])
      ¬∑ exact integrableOn_Icc_iff_integrableOn_Ioc.mp <| key‚ÇÜ f zero_lt_one
      ¬∑ rw [‚Üê neg_add']
        refine integrableOn_Ici_iff_integrableOn_Ioi.mp <| key‚Çá f hlim hT ?_
        rwa [ofReal_re]
    ¬∑ refine le_trans (norm_add_le _ _) <| le_trans (add_le_add_right (norm_sub_le _ _) _) ?_
      rw [norm_mul (((s : ‚ÑÇ) - 1) * s), norm_mul (((s : ‚ÑÇ) - 1) * s), norm_mul (((s : ‚ÑÇ) - 1) * s),
        show (((s : ‚ÑÇ) - 1) * s)  = ((s - 1) * s : ‚Ñù) by rw [ofReal_mul, ofReal_sub,
          ofReal_one], Complex.norm_real, Real.norm_of_nonneg hs']
    ¬∑ refine add_le_add (add_le_add ( mul_le_mul_of_nonneg_left ?_ hs')
        (mul_le_mul_of_nonneg_left ?_ hs')) ?_
      ¬∑ exact key‚Çà _ (by rwa [ofReal_re])
      ¬∑ exact key‚Çâ (by rwa [ofReal_re])
      ¬∑ rw [integral_sub, integral_mul_left]
        ¬∑ rw [‚Üê neg_add']
          exact integrableOn_Ici_iff_integrableOn_Ioi.mp <| key‚Çá f hlim hT (by rwa [ofReal_re])
        ¬∑ exact Integrable.const_mul (key‚ÇÖ hT (by rwa [ofReal_re])) _
    ¬∑ rw [mul_add]
      congr 3
      refine setIntegral_congr_fun measurableSet_Ioi fun t ht ‚Ü¶ ?_
      rw [sub_mul, cpow_sub, cpow_one, mul_assoc, mul_div_cancel‚ÇÄ]
      all_goals exact_mod_cast (hT.trans ht).ne'
    ¬∑ refine add_le_add_left (mul_le_mul_of_nonneg_left ?_ hs') _
      exact le_of_le_of_eq (norm_integral_le_integral_norm _) (by simp_rw [norm_mul])
    ¬∑ refine add_le_add_left (mul_le_mul_of_nonneg_left
        (setIntegral_mono_on ?_ ?_ measurableSet_Ioi ?_) hs') _
      ¬∑ refine Integrable.mono (key‚ÇÅ‚ÇÄ Œµ hT (by rwa [ofReal_re])) ?_
          ((ae_restrict_iff' measurableSet_Ioi).mpr ?_)
        ¬∑ refine Measurable.aestronglyMeasurable ?_
          exact key‚ÇÅ‚ÇÅ.mul (by fun_prop)
        ¬∑ filter_upwards with t ht
          rw [Real.norm_of_nonneg (by positivity), Real.norm_of_nonneg (by positivity)]
          exact hT' t ht
      ¬∑ refine key‚ÇÅ‚ÇÄ Œµ hT (by rwa [ofReal_re])
      ¬∑ exact hT'
    ¬∑ refine add_le_add_left (mul_le_mul_of_nonneg_left ?_ hs') _
      refine setIntegral_mono_set ?_ ?_ ?_
      ¬∑ refine key‚ÇÅ‚ÇÄ _ zero_lt_one (by rwa [ofReal_re])
      ¬∑ filter_upwards with _ using mul_nonneg (norm_nonneg _) (norm_nonneg _)
      ¬∑ exact HasSubset.Subset.eventuallyLE <| Set.Ioi_subset_Ioi (le_max_left 1 T‚ÇÄ)
    ¬∑ congr 2
      refine setIntegral_congr_fun measurableSet_Ioi fun t ht ‚Ü¶ ?_
      rw [norm_mul, ‚Üê norm_real t, mul_assoc, ‚Üê norm_mul, Real.norm_of_nonneg hŒµ.le, cpow_sub,
        cpow_one, mul_div_cancel‚ÇÄ]
      all_goals exact ne_zero_of_one_lt_re ht
    ¬∑ rw [integral_mul_left, ‚Üê mul_assoc, ‚Üê mul_assoc, ‚Üê mul_rotate _ s]
      congr 2
      refine setIntegral_congr_fun measurableSet_Ioi fun t ht ‚Ü¶ ?_
      rw [aux‚ÇÑ‚ÇÄ (zero_lt_one.trans ht), neg_re, ofReal_re]

include hlim hfS in
theorem final : Tendsto (fun s : ‚Ñù ‚Ü¶ (s - 1) * LSeries f s) (ùìù[>] 1) (ùìù l) := by
  refine Metric.tendsto_nhdsWithin_nhds.mpr fun Œµ hŒµ ‚Ü¶ ?_
  have hŒµ6 : 0 < Œµ / 6 := by positivity
  have hŒµ3 : 0 < Œµ / 3 := by positivity
  obtain ‚ü®C, hC‚ÇÅ, hC‚ÇÇ‚ü© := key_step f hlim hfS hŒµ6
  have lim1 : Tendsto (fun s ‚Ü¶ (s - 1) * s * C) (ùìù[>] 1) (ùìù 0) := by
    have : ContinuousAt (fun s ‚Ü¶ (s - 1) * s * C) 1 := by fun_prop
    convert tendsto_nhdsWithin_of_tendsto_nhds this.tendsto
    rw [sub_self, zero_mul, zero_mul]
  have lim2 : Tendsto (fun s : ‚Ñù ‚Ü¶ s * l) (ùìù[>] 1) (ùìù l) := by
    have : ContinuousAt (fun s : ‚Ñù ‚Ü¶ s * l) 1 := by fun_prop
    convert tendsto_nhdsWithin_of_tendsto_nhds this.tendsto
    rw [Complex.ofReal_one, one_mul]
  rw [Metric.tendsto_nhdsWithin_nhds] at lim1 lim2
  obtain ‚ü®Œ¥‚ÇÅ, _, hŒ¥‚ÇÅ‚ü© := lim1 _ hŒµ3
  obtain ‚ü®Œ¥‚ÇÇ, _, hŒ¥‚ÇÇ‚ü© := lim2 _ hŒµ3
  refine ‚ü®min 1 (min Œ¥‚ÇÅ Œ¥‚ÇÇ), by positivity, fun s hs‚ÇÅ hs‚ÇÇ ‚Ü¶ ?_‚ü©
  specialize hC‚ÇÇ s hs‚ÇÅ
  specialize hŒ¥‚ÇÅ hs‚ÇÅ <| hs‚ÇÇ.trans_le <| (min_le_right _ _).trans (min_le_left _ _)
  specialize hŒ¥‚ÇÇ hs‚ÇÅ <| hs‚ÇÇ.trans_le <| (min_le_right _ _).trans (min_le_right _ _)
  rw [dist_eq_norm] at hŒ¥‚ÇÅ hŒ¥‚ÇÇ hs‚ÇÇ ‚ä¢
  rw [sub_zero, Real.norm_of_nonneg (mul_nonneg
    (mul_nonneg (sub_nonneg.mpr hs‚ÇÅ.le) (zero_lt_one.trans hs‚ÇÅ).le) hC‚ÇÅ)] at hŒ¥‚ÇÅ
  have sle2 : s < 2 := by
    have := (abs_lt.mp <| Real.norm_eq_abs _ ‚ñ∏ (hs‚ÇÇ.trans_le (min_le_left _ _))).2
    rwa [sub_lt_iff_lt_add', one_add_one_eq_two] at this
  calc
    _ ‚â§ ‚Äñ(s - 1) * LSeries f s - l * s‚Äñ + ‚Äñl * s - l‚Äñ := norm_sub_le_norm_sub_add_norm_sub _ _ _
    _ < (s - 1) * s * C + s * (Œµ / 6) + (Œµ / 3) := add_lt_add_of_le_of_lt hC‚ÇÇ (by rwa [mul_comm])
    _ ‚â§ (Œµ / 3) + s * (Œµ / 6) + (Œµ / 3) := by gcongr
    _ < (Œµ / 3) + (Œµ / 3) + (Œµ / 3) := ?_
    _ = Œµ := add_thirds Œµ
  refine add_lt_add_right (add_lt_add_left ?_ (Œµ / 3)) (Œµ / 3)
  exact lt_of_lt_of_eq ((mul_lt_mul_right hŒµ6).mpr sle2) (by ring)

theorem final_real (f : ‚Ñï ‚Üí ‚Ñù) {l : ‚Ñù}
    (hf : Tendsto (fun n ‚Ü¶ (‚àë k ‚àà Icc 1 n, f k) / (n : ‚Ñù)) atTop (ùìù l))
    (hf' : ‚àÄ n, 0 ‚â§ f n) :
    Tendsto (fun s : ‚Ñù ‚Ü¶ (s - 1) * LSeries (fun n ‚Ü¶ f n) s) (ùìù[>] 1) (ùìù l) := by
  refine final (fun n ‚Ü¶ f n) (hf.ofReal.congr fun _ ‚Ü¶ ?_) fun s hs ‚Ü¶
    LSeriesSummable_of_sum_norm_bigO (f := fun n ‚Ü¶ f n) ?_ zero_le_one (by rwa [ofReal_re])
  ¬∑ simp only [ofReal_div, ofReal_sum, ofReal_natCast]
  ¬∑ convert Asymptotics.IsBigO.norm_left <| key‚ÇÉ (fun n ‚Ü¶ f n) ?_ (l := l)
    ¬∑ rw [‚Üê ofReal_sum, norm_real, Real.norm_of_nonneg (Finset.sum_nonneg fun _ _ ‚Ü¶ hf' _)]
      simp_rw [norm_real, Real.norm_of_nonneg (hf' _)]
    ¬∑ simp_rw [‚Üê ofReal_sum, ‚Üê ofReal_natCast, ‚Üê ofReal_div]
      exact tendsto_ofReal_iff.mpr hf
